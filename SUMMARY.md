The development of this project followed an incremental, feedback-driven process centered around careful planning, continuous testing, and repeated refinement. Rather than rushing to write large amounts of code at once, I took a deliberate approach: implement one small feature, verify that it works, document the change, and only then proceed to the next step. This cycle became the backbone of my workflow and allowed me to build a fully functional terminal-based application with a clear structure and predictable behavior.
My process began by creating isolated environments for each task using uv. This decision allowed me to experiment freely without worrying about dependency conflicts or accidentally breaking earlier tasks. The first challenge I faced was simply organizing the project so that each task could run independently while still following a consistent structure. Several early errors such as modules not being recognized or scripts not running due to incorrect paths forced me to rethink the folder layout. Through trial and error, combined with small tests and terminal experimentation, I eventually settled on a structure that supported both modularity and simplicity.
AI tools played an important role during all stages of development. When designing features or deciding how to structure a component, I used conversational assistance (similar to ChatGPT) to sketch out ideas, refine design decisions, and explore different implementation options. The assistant served as a brainstorming partner rather than an auto-complete machine; I described the behavior I wanted, and it suggested approaches, algorithms, or data structures that could support that behavior. However, I did not rely on it blindly. Many model suggestions required modification or partial rewriting to fit the constraints of a terminal environment or the broader architecture of my project. Still, having an AI collaborator shortened the time it took to overcome conceptual roadblocks.
When writing actual code especially repetitive boilerplate or small patches I also relied on AI assistance, but in controlled, minimal ways. I preferred code suggestions that were narrowly scoped: one function, an argument update, or a small refactor. This made debugging easier because I always knew exactly what had changed. Whenever an AI-suggested edit caused errors, I caught them quickly because I ran the program after every patch. Some mistakes were subtle, such as forgetting to update a function signature after adding a new CLI argument, or mismatching dictionary keys between the loader and the saver. In each case, the immediate feedback loop helped me fix the problem before it spread.
Debugging became more challenging once I began implementing interactive, terminal-based features. Designing menus, handling user input, and ensuring that the screen displayed correctly required multiple iterations. Small formatting problems quickly turned into larger issues: misaligned text, menus that did not refresh correctly, and error messages that appeared in the wrong place. One of the most frustrating challenges was making sure that destructive actions such as clearing data required explicit confirmation. In the terminal, it is easy for input to be captured incorrectly or ignored entirely, so I had to test these flows repeatedly, simulating user input and ensuring every prompt worked exactly as intended.
Another major challenge was integrating optional dependencies such as the OpenAI API. I wanted the project to function without network access, which meant creating clear fallbacks that prevented crashes when the API key was missing. At first, missing-key errors appeared deep inside the call stack, making them hard to diagnose. Over time, I built a system that gated all LLM usage behind explicit environment checks and graceful error handling. These iterative fixes made the application more robust and predictable.
Spec-Kit introduced its own difficulties, especially due to version mismatches and changes in how AI agents were generated. I had to reinstall earlier versions, regenerate parts of the project, and repeatedly verify folder structure to avoid the common mistake of accidentally pushing .git from inside the generated folder. These challenges were solved mostly through repeated trial, reading documentation, and using conversational AI to interpret ambiguous instructions.
Throughout the entire development cycle, the process that worked best was the emphasis on small, testable steps. Every mistake became a learning opportunity and every failed test clarified what needed to be fixed. The process that did not work as well and which I had to abandon early was attempting large feature additions in single patches. Whenever I tried that approach, I ended up with multiple bugs at once, making debugging substantially harder. Returning to small, predictable commits restored stability.
By the end of the project, I had built not only functional software but also a deeper understanding of how disciplined incremental development, combined with AI assistance and careful terminal testing, can produce reliable and maintainable code. The challenges I faced terminal formatting, debugging user flows, integrating APIs, managing project structure, and resolving spec-kit issues ultimately strengthened the final product and improved my confidence as a developer.

